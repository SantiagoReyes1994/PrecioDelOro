[["index.html", "Precio Del Oro Capítulo 1 DATA SET SELECCIONADO 1.1 NOMBRE: Daily Gold Price (2014-2022) Time Series en Kaggle 1.2 DESCRIPCIÓN: 1.3 RANGO DE FECHAS:01/01/2014-05/08/2022 1.4 REGISTROS: 2.227 1.5 VARIABLES: 1.6 IMPORTANCIA:", " Precio Del Oro Grupo 2: Santiago Reyes, Francisco Santos, Fabian Maldonado 2024-06-17 Capítulo 1 DATA SET SELECCIONADO 1.1 NOMBRE: Daily Gold Price (2014-2022) Time Series en Kaggle 1.2 DESCRIPCIÓN: Conjunto de datos proporciona los precios diarios del oro desde 2015 hasta 2021. Cada entrada incluye la fecha y el precio del oro en dólares estadounidenses (USD). 1.3 RANGO DE FECHAS:01/01/2014-05/08/2022 1.4 REGISTROS: 2.227 1.5 VARIABLES: Este Dataset contiene las siguientes variables: • Fecha (Date): Representa la fecha en la que se registró el precio del oro. Por ejemplo, “24 de abril de 2015”. • Precio del oro (Price): Indica el valor del oro en dólares estadounidenses (USD) para esa fecha específica. Por ejemplo, “1,200 USD”. • Precio de apertura (Open): Corresponde al precio del oro al inicio del período de negociación. Por ejemplo, “1,180 USD”. • Precio máximo (High): Es el precio más alto alcanzado por el oro durante el día. Por ejemplo, “1,220 USD”. • Precio mínimo (Low): Representa el precio más bajo registrado para el oro durante el día. Por ejemplo, “1,150 USD”. • Volumen (Volume): Indica la cantidad total de oro negociada en ese día. Por ejemplo, “10,000 onzas”. • Variación porcentual (Chg%): Muestra el cambio porcentual en el precio del oro con respecto al día anterior. Por ejemplo, “+2.5%” o “-1.8%”. 1.6 IMPORTANCIA: 1.6.1 Relevancia económica: El oro ha sido una parte integral de la economía mundial durante milenios y sigue siendo relevante en la economía contemporánea por varias razones: El oro ha sido considerado tradicionalmente como una reserva de valor estable. A lo largo de la historia, ha conservado su valor mejor que muchas otras formas de inversión, lo que lo convierte en un refugio seguro en tiempos de incertidumbre económica, Los inversores y los bancos centrales a menudo mantienen oro como parte de una cartera diversificada. Dado que el oro tiene una correlación baja o negativa con otros activos. Además de su valor como inversión, el oro tiene numerosos usos industriales y tecnológicos. Se utiliza en la electrónica, la odontología, la medicina entre otros campos. 1.6.2 Análisis de tendencias: Estudiar la serie temporal de precios del oro permite identificar cambios en el sentimiento económico y la confianza del mercado. Por ejemplo, un aumento en el precio del oro a menudo indica preocupaciones sobre la inflación, la inestabilidad geopolítica o la incertidumbre económica, Para los inversionistas, el oro puede servir como una forma de diversificar sus carteras y mitigar el riesgo. Estudiar las fluctuaciones en su precio les permite ajustar sus asignaciones de activos según las condiciones del mercado. Históricamente ha demostrado ser un activo que puede actuar como cobertura contra la inflación. Los bancos, en particular, pueden estudiar las fluctuaciones en el precio del oro para informar sus decisiones de política monetaria y de inversión. Las reservas de oro de un banco central pueden influir en su política monetaria y en su capacidad para estabilizar la moneda nacional. Por último, : Los movimientos extremos en el precio del oro a menudo pueden indicar riesgos sistémicos en la economía o en los mercados financieros. 1.6.3 Modelos de predicción: Utilizando estos datos, se pueden construir modelos de predicción para estimar los precios futuros del oro y cambios importantes. Se pueden aplicar modelos como: • Modelos ARIMA (Autoregressive Integrated Moving Average): Son adecuados para series temporales estacionarias y pueden capturar tanto la autocorrelación como la estacionalidad en los datos. • Suavizado exponencial: Modelo es útil para suavizar las fluctuaciones en los datos y capturar tendencias a largo plazo. Es especialmente útil cuando los datos tienen una tendencia y/o estacionalidad que cambia con el tiempo. • Redes Neuronales Recurrentes (RNN) y Redes Neuronales Convolucionales (CNN): Estos modelos son capaces de capturar patrones complejos en los datos y pueden adaptarse a una amplia variedad de situaciones. • Modelos de regresión: Son útiles para analizar la relación entre la serie temporal de interés y otras variables predictoras. • Modelos de media móvil generalizada (GARCH): Son útiles para modelar la volatilidad en series temporales financieras. 1.6.4 Investigación académica: Los datos históricos del oro son útiles para investigaciones académicas en campos como la economía, las finanzas y la econometría. 1.6.5 Granularidad diaria: El tener información tan detallada del comportamiento diario es valioso para tener datos solidos y de gran confiabilidad. "],["propuesta-avance-2-3.html", "Capítulo 2 Propuesta Avance 2 &amp; 3 2.1 Cargar Librerias a usar 2.2 Cargar la data del Data set 2.3 Limpieza de Datos 2.4 Padding &amp; imputation 2.5 Exploración de la data 2.6 Descomposición de la Serie Temporal 2.7 Análisis de estacionalidad 2.8 Análisis de Diferenciación 2.9 Transformación para Controlar la Tendencia y Variabilidad 2.10 Justificación", " Capítulo 2 Propuesta Avance 2 &amp; 3 2.1 Cargar Librerias a usar suppressMessages({ library(lubridate) library(forecast) library(MLmetrics) library(tseries) library(TSstudio) library(padr) library(imputeTS) library(ggplot2) library(tidyverse) theme_set(theme_minimal()) }) 2.2 Cargar la data del Data set data = read.csv(&quot;Gold Price.csv&quot;) head(data) ## Date Price Open High Low Volume Chg. ## 1 2014-01-01 29542 29435 29598 29340 2930 0.25 ## 2 2014-01-02 29975 29678 30050 29678 3140 1.47 ## 3 2014-01-03 29727 30031 30125 29539 3050 -0.83 ## 4 2014-01-04 29279 29279 29279 29279 0 -1.51 ## 5 2014-01-06 29119 29300 29395 29051 24380 -0.55 ## 6 2014-01-07 28959 29130 29195 28912 18710 -0.55 2.3 Limpieza de Datos # Validar los tipos de datos de cada Columna str(data) ## &#39;data.frame&#39;: 2227 obs. of 7 variables: ## $ Date : chr &quot;2014-01-01&quot; &quot;2014-01-02&quot; &quot;2014-01-03&quot; &quot;2014-01-04&quot; ... ## $ Price : int 29542 29975 29727 29279 29119 28959 28934 28997 29169 29312 ... ## $ Open : int 29435 29678 30031 29279 29300 29130 28916 28990 29030 29170 ... ## $ High : int 29598 30050 30125 29279 29395 29195 29029 29053 29198 29330 ... ## $ Low : int 29340 29678 29539 29279 29051 28912 28820 28865 28960 29133 ... ## $ Volume: int 2930 3140 3050 0 24380 18710 18140 15130 15810 13780 ... ## $ Chg. : num 0.25 1.47 -0.83 -1.51 -0.55 -0.55 -0.09 0.22 0.59 0.49 ... Se ajusta la columna “Date” está en tipo “character”, por lo tanto toca convertir esta en formato de Tiempo data &lt;- data %&gt;% mutate(Date = ymd(Date)) str(data) ## &#39;data.frame&#39;: 2227 obs. of 7 variables: ## $ Date : Date, format: &quot;2014-01-01&quot; &quot;2014-01-02&quot; ... ## $ Price : int 29542 29975 29727 29279 29119 28959 28934 28997 29169 29312 ... ## $ Open : int 29435 29678 30031 29279 29300 29130 28916 28990 29030 29170 ... ## $ High : int 29598 30050 30125 29279 29395 29195 29029 29053 29198 29330 ... ## $ Low : int 29340 29678 29539 29279 29051 28912 28820 28865 28960 29133 ... ## $ Volume: int 2930 3140 3050 0 24380 18710 18140 15130 15810 13780 ... ## $ Chg. : num 0.25 1.47 -0.83 -1.51 -0.55 -0.55 -0.09 0.22 0.59 0.49 ... Se identifica que Todas las columnas se encuentran en el tipo correcto. 2.4 Padding &amp; imputation Si observamos la data solo comprende fechas entre semana, pero en series de tiempo deberíamos tener la data mas completa en la medida de lo posible. # Padding data &lt;- data %&gt;% pad(interval = &quot;day&quot;) suppressWarnings({ # Imputar NA values con la última observación data_clean &lt;- data %&gt;% na.locf() }) head(data_clean) ## Date Price Open High Low Volume Chg. ## 1 2014-01-01 29542 29435 29598 29340 2930 0.25 ## 2 2014-01-02 29975 29678 30050 29678 3140 1.47 ## 3 2014-01-03 29727 30031 30125 29539 3050 -0.83 ## 4 2014-01-04 29279 29279 29279 29279 0 -1.51 ## 5 2014-01-05 29279 29279 29279 29279 0 -1.51 ## 6 2014-01-06 29119 29300 29395 29051 24380 -0.55 2.5 Exploración de la data Para explorar la data debemos primero crear el objeto de serie de tiempo # ts data_ts &lt;- ts(data = data_clean$Price, start = 2014, frequency = 7*4*12) data_ts %&gt;% autoplot() Se observa un comportamiento INCREMENTAL a traves del tiempo y adicionalmente se podria inferir un modelo multiplicativo # Calcular el promedio móvil promedio_movil &lt;- ma(data_ts, order = 12) autoplot(data_ts) + ggtitle(&quot;Serie de Tiempo&quot;) + autolayer(promedio_movil, series = &quot;Promedio Móvil&quot;) ## Warning: Removed 12 rows containing missing values or values outside the scale range ## (`geom_line()`). Se observa que el promedio móvil sigue de cerca la serie temporal, lo que sugiere una presencia limitada de ruido en los datos y una tendencia clara en su evolución. 2.6 Descomposición de la Serie Temporal Se realiza la descomposición de la serie temporal en sus componentes de tendencia, estacionalidad y residuos data_decompose &lt;- data_ts %&gt;% decompose(type = &quot;multiplicative&quot;) data_decompose %&gt;% autoplot() Se evidencia claramente una tendencia lineal en los datos, acompañada de un patrón de estacionalidad adicional. 2.7 Análisis de estacionalidad data_decompose$seasonal %&gt;% autoplot() Después de la visualización del componente estacional de la serie temporal, se procederá a analizar y validar un posible patrón en los precios del oro entre los años 2014 y 2023. Este análisis ayudará a comprender mejor la naturaleza de la estacionalidad presente en los datos a lo largo de este período ggseasonplot(data_ts, year.labels = TRUE, year.labels.left = TRUE) + labs(title = &quot;Gráfico Estacional de Precios del Oro (Múltiples Años)&quot;, x = &quot;Mes&quot;, y = &quot;Precio&quot;) + theme_minimal() Se observa un patrón recurrente en los precios, con picos y valles que parecen repetirse cada año. Se identifica una trendencia incremental constante del periodo 2019 al 2022 principalmente Alicamos La prueba de Dickey-Fuller Aumentada (ADF) para determinar si una serie temporal es estacionaria o no. suppressMessages({ # Prueba de estacionariedad (ADF) adf_test &lt;- adf.test(data_ts) adf_test }) ## ## Augmented Dickey-Fuller Test ## ## data: data_ts ## Dickey-Fuller = -2.1155, Lag order = 14, p-value = 0.5294 ## alternative hypothesis: stationary La prueba de Dickey-Fuller aumentada (ADF) identifica que la serie temporal no es estacionaria. Esto se basa en el estadístico de prueba (-2.1155) y el valor p (0.5294). Dado que el valor p es mayor que el nivel de significancia típico de 0.05, no hay suficiente evidencia para rechazar la hipótesis nula de no estacionariedad. Dado que la serie no es estacionaria según la prueba ADF, Proceedemos con la diferenciación 2.8 Análisis de Diferenciación Se realiza un analisis comparativo de los meses identificando el comportamiento data_clean %&gt;% mutate(Month = month(Date, label = T)) %&gt;% mutate(seasons = data_decompose$seasonal) %&gt;% group_by(Month) %&gt;% summarise(total = sum(seasons)) %&gt;% ggplot(aes(Month, total)) + geom_col()+ theme_minimal() El análisis de la estacionalidad mensual revela patrones en los precios del oro a lo largo del año. Se observa que estos son más altos durante enero a julio, mientras que disminuyen de agosto a diciembre # Diferenciación de la serie temporal diff_data_ts &lt;- diff(data_ts) autoplot(diff_data_ts) + labs(title = &quot;Serie Diferenciada&quot;, y = &quot;Diferencia&quot;, x = &quot;Tiempo&quot;) Con este grafico observamos parecen más amplias entre sí durante el año 2020 y 2021, lo que indica cambios significativos en el comportamiento de la serie durante ese año Continuamos el análisis al representar tanto la serie temporal original como la serie diferenciada en un único gráfico. # Diferenciación de la serie temporal diff_data_ts &lt;- diff(data_ts) par(mfrow=c(2,1)) plot(data_ts, main=&quot;Serie Original&quot;, ylab=&quot;Valor&quot;, xlab=&quot;Tiempo&quot;) plot(diff_data_ts, main=&quot;Serie Diferenciada&quot;, ylab=&quot;Diferencia&quot;, xlab=&quot;Tiempo&quot;) Esto nos permite comparar visualmente cómo cambian los datos después de aplicar la diferenciación. # Calcular la función de autocorrelación (ACF) acf_diff &lt;- acf(diff_data_ts, main = &quot;Función de Autocorrelación (ACF) de la Serie Diferenciada&quot;) # Calcular la función de autocorrelación parcial (PACF) pacf_diff &lt;- pacf(diff_data_ts, main = &quot;Función de Autocorrelación Parcial (PACF) de la Serie Diferenciada&quot;) Los coeficientes de correlación fuera de estos límites son estadísticamente significativos. el limigte superio es de :0.0349826 y el inferior de: -0.0349826 suppressMessages({ # Prueba ADF en la serie diferenciada adf_test_diff &lt;- adf.test(diff_data_ts) adf_test_diff }) ## Warning in adf.test(diff_data_ts): p-value smaller than printed p-value ## ## Augmented Dickey-Fuller Test ## ## data: diff_data_ts ## Dickey-Fuller = -15.347, Lag order = 14, p-value = 0.01 ## alternative hypothesis: stationary Se aplico la prueba ADF en la serie diferenciada arrojó un estadístico de prueba de -15.347 y un valor p de 0.01. Estos resultados indican una evidencia que la serie temporal tiene una tendencia constante unitaria , lo que implica que la serie es estacionaria. 2.9 Transformación para Controlar la Tendencia y Variabilidad # Transformación logarítmica log_data_ts &lt;- log(data_ts) # Gráfico de la serie transformada plot(log_data_ts, main=&quot;Serie Transformada (Logarítmica)&quot;, ylab=&quot;Valor Transformado&quot;, xlab=&quot;Tiempo&quot;) # Cargar el paquete knitr library(knitr) ## Warning: package &#39;knitr&#39; was built under R version 4.3.3 # métricas antes de la transformación cv_before &lt;- sd(data_ts) / mean(data_ts) * 100 sd_before &lt;- sd(data_ts) iqr_before &lt;- IQR(data_ts) # Aplicar la transformación logarítmica log_data_ts &lt;- log(data_ts) # métricas después de la transformación cv_after &lt;- sd(log_data_ts) / mean(log_data_ts) * 100 sd_after &lt;- sd(log_data_ts) iqr_after &lt;- IQR(log_data_ts) # Crear con los resultados results &lt;- data.frame( Métrica = c(&quot;Coeficiente de Variación (CV)&quot;, &quot;Desviación Estándar&quot;, &quot;Rango Intercuartílico (IQR)&quot;), Antes_de_la_Transformación = c(cv_before, sd_before, iqr_before), Después_de_la_Transformación = c(cv_after, sd_after, iqr_after) ) # Imprimir knitr::kable(results, caption = &quot;Métricas antes y después de la transformación&quot;) Table 2.1: Métricas antes y después de la transformación Métrica Antes_de_la_Transformación Después_de_la_Transformación Coeficiente de Variación (CV) 25.42391 2.2939376 Desviación Estándar 8961.58310 0.2394944 Rango Intercuartílico (IQR) 17332.00000 0.4742370 Antes de la transformación, el coeficiente de variación (CV) es 25.42, la desviación estándar es 8961.58 y el rango intercuartílico (IQR) es 17332. Después de la transformación, el CV se reduce significativamente a 2.29, la desviación estándar se reduce a 0.24 y el IQR se reduce a 0.47. Estas reducciones indican una disminución significativa en la variabilidad de la serie después de la transformación. 2.10 Justificación Prueba de Dickey-Fuller (ADF) estacionariedad : Es importante evaluar la estacionariedad de la serie temporal antes de aplicar modelos de series temporales. La prueba ADF nos permite determinar si la serie es estacionaria o no, lo que influye en la selección y aplicación de modelos adecuados. Diferenciación de la Serie Temporal: La diferenciación es un paso común para lograr la estacionariedad en series temporales no estacionarias. Eliminar tendencias y patrones no estacionarios permite aplicar modelos más simples y eficientes, adicionalmente mejorar la interpretabilidad de los resultados al eliminar tendencias y variaciones. la transformación: La transformación se utilizo para estabilizar la varianza y controlar la tendencia en la serie temporal. Esto es importante para mejorar la interpretacion de los datos y facilitar la identificación de patrones temporales. Además, la reducción de la variabilidad puede hacer que la serie sea más predecible y fácil de modela.. "],["avance-4.html", "Capítulo 3 Avance 4 3.1 Método de Holt-Winters: 3.2 Suavizamiento Exponencial: 3.3 Pronóstico: 3.4 Visualización: 3.5 Calculando las métricas para el suavizamiento exponencial", " Capítulo 3 Avance 4 3.1 Método de Holt-Winters: El método de Holt-Winters es una técnica de suavizado exponencial que se utiliza comúnmente para pronosticar datos de series de tiempo. Se compone de tres componentes: nivel, tendencia y estacionalidad. 3.2 Suavizamiento Exponencial: Primero, aplicaremos el suavizamiento exponencial simple para suavizar la serie de tiempo y estimar los valores de nivel, tendencia y estacionalidad library(forecast) library(ggplot2) # Cargar los datos data &lt;- read.csv(&quot;Gold Price.csv&quot;) # Convertir la columna &quot;Date&quot; en formato de fecha data$Date &lt;- as.Date(data$Date) # Crear la serie temporal data_ts &lt;- ts(data$Price, start = c(2015, 1), frequency = 12) hw_model &lt;- HoltWinters(data_ts) 3.3 Pronóstico: Luego, utilizaremos el modelo Holt-Winters para hacer pronósticos futuros. en un 12 meses # Pronóstico hw_forecast &lt;- forecast(hw_model, h = 12) # Pronosticar los próximos 12 meses 3.3.1 Suavizamiento Exponencial: Además, aplicaremos el suavizamiento exponencial simple para obtener una versión suavizada de la serie de tiempo. exp_smooth &lt;- HoltWinters(data_ts, beta = FALSE, gamma = FALSE) smoothed_data &lt;- forecast:::forecast.HoltWinters(exp_smooth, h = length(data_ts)) 3.4 Visualización: Finalmente, visualizaremos los resultados del método de Holt-Winters y del suavizamiento exponencial. autoplot(hw_forecast) + autolayer(data_ts, series = &quot;Precio Oro&quot;) + xlab(&quot;Año&quot;) + ylab(&quot;Precio&quot;) + ggtitle(&quot;Pronóstico del Precio del Oro con Holt-Winters&quot;) # Visualización de suavizamiento exponencial autoplot(smoothed_data) + autolayer(data_ts, series = &quot;Precio Oro&quot;) + xlab(&quot;Año&quot;) + ylab(&quot;Precio&quot;) + ggtitle(&quot;Suavizamiento Exponencial del Precio del Oro&quot;) ## Calculando las métricas para el método de Holt-Winters hw_accuracy &lt;- accuracy(hw_forecast) print(&quot;Métricas para Holt-Winters:&quot;) ## [1] &quot;Métricas para Holt-Winters:&quot; print(hw_accuracy) ## ME RMSE MAE MPE MAPE MASE ## Training set -4.547451 330.3763 226.7895 -0.02156372 0.6362722 0.2941997 ## ACF1 ## Training set 0.02910049 3.5 Calculando las métricas para el suavizamiento exponencial smoothed_accuracy &lt;- accuracy(smoothed_data) print(&quot;Métricas para Suavizamiento Exponencial:&quot;) ## [1] &quot;Métricas para Suavizamiento Exponencial:&quot; print(smoothed_accuracy) ## ME RMSE MAE MPE MAPE MASE ## Training set 10.41807 322.2341 217.4095 0.02246437 0.6065303 0.2820317 ## ACF1 ## Training set -0.002075383 Los resultados de las métricas proporcionan una comparación entre el método de Holt-Winters y el suavizamiento exponencial en términos de su desempeño en la serie temporal de precios del oro. • ME (Error Medio): Ambos métodos tienen errores medios cercanos a cero, lo que indica que en promedio no están sesgados en sus pronósticos. • RMSE (Error Cuadrático Medio): El suavizamiento exponencial tiene un RMSE ligeramente más bajo (271.2025) en comparación con Holt-Winters (308.2692). Un RMSE más bajo indica que el suavizamiento exponencial tiene un mejor ajuste a los datos de entrenamiento. • MAE (Error Absoluto Medio): Similar al RMSE, el suavizamiento exponencial también tiene un MAE más bajo (155.8932) en comparación con Holt-Winters (195.5094). Esto indica que, en promedio, las predicciones del suavizamiento exponencial tienden a desviarse menos de los valores reales que las predicciones de Holt-Winters. • MPE (Error Porcentual Medio): Ambos métodos tienen valores de MPE cercanos a cero, lo que indica que, en promedio, no hay un sesgo significativo en los pronósticos. • MAPE (Error Porcentual Absoluto Medio): El suavizamiento exponencial tiene un MAPE ligeramente más bajo (0.4349868) en comparación con Holt-Winters (0.5384692). Un MAPE más bajo indica que el suavizamiento exponencial tiene una precisión porcentualmente mejor en sus predicciones. • MASE (Error Medio Absoluto Escalado): Similar al MAE, el suavizamiento exponencial tiene un MASE más bajo (0.04096972) en comparación con Holt-Winters (0.05138109). Un MASE más bajo indica que el suavizamiento exponencial tiene una mejor capacidad relativa para predecir la serie temporal en comparación con un método de referencia (generalmente el promedio histórico). • ACF1 (Autocorrelación de Primer Orden de los Residuos): Ambos métodos muestran valores de autocorrelación cercanos a cero, lo que indica que los residuos no exhiben una autocorrelación significativa. los resultados sugieren que el suavizamiento exponencial tiene un mejor desempeño en términos de precisión y ajuste a los datos de entrenamiento en comparación con el método de Holt-Winters para esta serie temporal. "],["avance-5.html", "Capítulo 4 Avance 5", " Capítulo 4 Avance 5 Esta es una prueba para cargar el avance 5 "]]
