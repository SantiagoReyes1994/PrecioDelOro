[["propuesta-avance-2-3.html", "Capítulo 2 Propuesta Avance 2 &amp; 3 2.1 Cargar Librerias a usar 2.2 Cargar la data del Data set 2.3 Limpieza de Datos 2.4 Padding &amp; imputation 2.5 Exploración de la data 2.6 Descomposición de la Serie Temporal 2.7 Análisis de estacionalidad 2.8 Análisis de Diferenciación 2.9 Transformación para Controlar la Tendencia y Variabilidad 2.10 Justificación", " Capítulo 2 Propuesta Avance 2 &amp; 3 2.1 Cargar Librerias a usar suppressMessages({ library(lubridate) library(forecast) library(MLmetrics) library(tseries) library(TSstudio) library(padr) library(imputeTS) library(ggplot2) library(tidyverse) theme_set(theme_minimal()) }) 2.2 Cargar la data del Data set data = read.csv(&quot;Gold Price.csv&quot;) head(data) ## Date Price Open High Low Volume Chg. ## 1 2014-01-01 29542 29435 29598 29340 2930 0.25 ## 2 2014-01-02 29975 29678 30050 29678 3140 1.47 ## 3 2014-01-03 29727 30031 30125 29539 3050 -0.83 ## 4 2014-01-04 29279 29279 29279 29279 0 -1.51 ## 5 2014-01-06 29119 29300 29395 29051 24380 -0.55 ## 6 2014-01-07 28959 29130 29195 28912 18710 -0.55 2.3 Limpieza de Datos # Validar los tipos de datos de cada Columna str(data) ## &#39;data.frame&#39;: 2227 obs. of 7 variables: ## $ Date : chr &quot;2014-01-01&quot; &quot;2014-01-02&quot; &quot;2014-01-03&quot; &quot;2014-01-04&quot; ... ## $ Price : int 29542 29975 29727 29279 29119 28959 28934 28997 29169 29312 ... ## $ Open : int 29435 29678 30031 29279 29300 29130 28916 28990 29030 29170 ... ## $ High : int 29598 30050 30125 29279 29395 29195 29029 29053 29198 29330 ... ## $ Low : int 29340 29678 29539 29279 29051 28912 28820 28865 28960 29133 ... ## $ Volume: int 2930 3140 3050 0 24380 18710 18140 15130 15810 13780 ... ## $ Chg. : num 0.25 1.47 -0.83 -1.51 -0.55 -0.55 -0.09 0.22 0.59 0.49 ... Se ajusta la columna “Date” está en tipo “character”, por lo tanto toca convertir esta en formato de Tiempo data &lt;- data %&gt;% mutate(Date = ymd(Date)) str(data) ## &#39;data.frame&#39;: 2227 obs. of 7 variables: ## $ Date : Date, format: &quot;2014-01-01&quot; &quot;2014-01-02&quot; ... ## $ Price : int 29542 29975 29727 29279 29119 28959 28934 28997 29169 29312 ... ## $ Open : int 29435 29678 30031 29279 29300 29130 28916 28990 29030 29170 ... ## $ High : int 29598 30050 30125 29279 29395 29195 29029 29053 29198 29330 ... ## $ Low : int 29340 29678 29539 29279 29051 28912 28820 28865 28960 29133 ... ## $ Volume: int 2930 3140 3050 0 24380 18710 18140 15130 15810 13780 ... ## $ Chg. : num 0.25 1.47 -0.83 -1.51 -0.55 -0.55 -0.09 0.22 0.59 0.49 ... Se identifica que Todas las columnas se encuentran en el tipo correcto. 2.4 Padding &amp; imputation Si observamos la data solo comprende fechas entre semana, pero en series de tiempo deberíamos tener la data mas completa en la medida de lo posible. # Padding data &lt;- data %&gt;% pad(interval = &quot;day&quot;) suppressWarnings({ # Imputar NA values con la última observación data_clean &lt;- data %&gt;% na.locf() }) head(data_clean) ## Date Price Open High Low Volume Chg. ## 1 2014-01-01 29542 29435 29598 29340 2930 0.25 ## 2 2014-01-02 29975 29678 30050 29678 3140 1.47 ## 3 2014-01-03 29727 30031 30125 29539 3050 -0.83 ## 4 2014-01-04 29279 29279 29279 29279 0 -1.51 ## 5 2014-01-05 29279 29279 29279 29279 0 -1.51 ## 6 2014-01-06 29119 29300 29395 29051 24380 -0.55 2.5 Exploración de la data Para explorar la data debemos primero crear el objeto de serie de tiempo # ts data_ts &lt;- ts(data = data_clean$Price, start = 2014, frequency = 7*4*12) data_ts %&gt;% autoplot() Se observa un comportamiento INCREMENTAL a traves del tiempo y adicionalmente se podria inferir un modelo multiplicativo # Calcular el promedio móvil promedio_movil &lt;- ma(data_ts, order = 12) autoplot(data_ts) + ggtitle(&quot;Serie de Tiempo&quot;) + autolayer(promedio_movil, series = &quot;Promedio Móvil&quot;) ## Warning: Removed 12 rows containing missing values or values outside the scale range ## (`geom_line()`). Se observa que el promedio móvil sigue de cerca la serie temporal, lo que sugiere una presencia limitada de ruido en los datos y una tendencia clara en su evolución. 2.6 Descomposición de la Serie Temporal Se realiza la descomposición de la serie temporal en sus componentes de tendencia, estacionalidad y residuos data_decompose &lt;- data_ts %&gt;% decompose(type = &quot;multiplicative&quot;) data_decompose %&gt;% autoplot() Se evidencia claramente una tendencia lineal en los datos, acompañada de un patrón de estacionalidad adicional. 2.7 Análisis de estacionalidad data_decompose$seasonal %&gt;% autoplot() Después de la visualización del componente estacional de la serie temporal, se procederá a analizar y validar un posible patrón en los precios del oro entre los años 2014 y 2023. Este análisis ayudará a comprender mejor la naturaleza de la estacionalidad presente en los datos a lo largo de este período ggseasonplot(data_ts, year.labels = TRUE, year.labels.left = TRUE) + labs(title = &quot;Gráfico Estacional de Precios del Oro (Múltiples Años)&quot;, x = &quot;Mes&quot;, y = &quot;Precio&quot;) + theme_minimal() Se observa un patrón recurrente en los precios, con picos y valles que parecen repetirse cada año. Se identifica una trendencia incremental constante del periodo 2019 al 2022 principalmente Alicamos La prueba de Dickey-Fuller Aumentada (ADF) para determinar si una serie temporal es estacionaria o no. suppressMessages({ # Prueba de estacionariedad (ADF) adf_test &lt;- adf.test(data_ts) adf_test }) ## ## Augmented Dickey-Fuller Test ## ## data: data_ts ## Dickey-Fuller = -2.1155, Lag order = 14, p-value = 0.5294 ## alternative hypothesis: stationary La prueba de Dickey-Fuller aumentada (ADF) identifica que la serie temporal no es estacionaria. Esto se basa en el estadístico de prueba (-2.1155) y el valor p (0.5294). Dado que el valor p es mayor que el nivel de significancia típico de 0.05, no hay suficiente evidencia para rechazar la hipótesis nula de no estacionariedad. Dado que la serie no es estacionaria según la prueba ADF, Proceedemos con la diferenciación 2.8 Análisis de Diferenciación Se realiza un analisis comparativo de los meses identificando el comportamiento data_clean %&gt;% mutate(Month = month(Date, label = T)) %&gt;% mutate(seasons = data_decompose$seasonal) %&gt;% group_by(Month) %&gt;% summarise(total = sum(seasons)) %&gt;% ggplot(aes(Month, total)) + geom_col()+ theme_minimal() El análisis de la estacionalidad mensual revela patrones en los precios del oro a lo largo del año. Se observa que estos son más altos durante enero a julio, mientras que disminuyen de agosto a diciembre # Diferenciación de la serie temporal diff_data_ts &lt;- diff(data_ts) autoplot(diff_data_ts) + labs(title = &quot;Serie Diferenciada&quot;, y = &quot;Diferencia&quot;, x = &quot;Tiempo&quot;) Con este grafico observamos parecen más amplias entre sí durante el año 2020 y 2021, lo que indica cambios significativos en el comportamiento de la serie durante ese año Continuamos el análisis al representar tanto la serie temporal original como la serie diferenciada en un único gráfico. # Diferenciación de la serie temporal diff_data_ts &lt;- diff(data_ts) par(mfrow=c(2,1)) plot(data_ts, main=&quot;Serie Original&quot;, ylab=&quot;Valor&quot;, xlab=&quot;Tiempo&quot;) plot(diff_data_ts, main=&quot;Serie Diferenciada&quot;, ylab=&quot;Diferencia&quot;, xlab=&quot;Tiempo&quot;) Esto nos permite comparar visualmente cómo cambian los datos después de aplicar la diferenciación. # Calcular la función de autocorrelación (ACF) acf_diff &lt;- acf(diff_data_ts, main = &quot;Función de Autocorrelación (ACF) de la Serie Diferenciada&quot;) # Calcular la función de autocorrelación parcial (PACF) pacf_diff &lt;- pacf(diff_data_ts, main = &quot;Función de Autocorrelación Parcial (PACF) de la Serie Diferenciada&quot;) Los coeficientes de correlación fuera de estos límites son estadísticamente significativos. el limigte superio es de :0.0349826 y el inferior de: -0.0349826 suppressMessages({ # Prueba ADF en la serie diferenciada adf_test_diff &lt;- adf.test(diff_data_ts) adf_test_diff }) ## Warning in adf.test(diff_data_ts): p-value smaller than printed p-value ## ## Augmented Dickey-Fuller Test ## ## data: diff_data_ts ## Dickey-Fuller = -15.347, Lag order = 14, p-value = 0.01 ## alternative hypothesis: stationary Se aplico la prueba ADF en la serie diferenciada arrojó un estadístico de prueba de -15.347 y un valor p de 0.01. Estos resultados indican una evidencia que la serie temporal tiene una tendencia constante unitaria , lo que implica que la serie es estacionaria. 2.9 Transformación para Controlar la Tendencia y Variabilidad # Transformación logarítmica log_data_ts &lt;- log(data_ts) # Gráfico de la serie transformada plot(log_data_ts, main=&quot;Serie Transformada (Logarítmica)&quot;, ylab=&quot;Valor Transformado&quot;, xlab=&quot;Tiempo&quot;) # Cargar el paquete knitr library(knitr) # métricas antes de la transformación cv_before &lt;- sd(data_ts) / mean(data_ts) * 100 sd_before &lt;- sd(data_ts) iqr_before &lt;- IQR(data_ts) # Aplicar la transformación logarítmica log_data_ts &lt;- log(data_ts) # métricas después de la transformación cv_after &lt;- sd(log_data_ts) / mean(log_data_ts) * 100 sd_after &lt;- sd(log_data_ts) iqr_after &lt;- IQR(log_data_ts) # Crear con los resultados results &lt;- data.frame( Métrica = c(&quot;Coeficiente de Variación (CV)&quot;, &quot;Desviación Estándar&quot;, &quot;Rango Intercuartílico (IQR)&quot;), Antes_de_la_Transformación = c(cv_before, sd_before, iqr_before), Después_de_la_Transformación = c(cv_after, sd_after, iqr_after) ) # Imprimir knitr::kable(results, caption = &quot;Métricas antes y después de la transformación&quot;) Table 2.1: Métricas antes y después de la transformación Métrica Antes_de_la_Transformación Después_de_la_Transformación Coeficiente de Variación (CV) 25.42391 2.2939376 Desviación Estándar 8961.58310 0.2394944 Rango Intercuartílico (IQR) 17332.00000 0.4742370 Antes de la transformación, el coeficiente de variación (CV) es 25.42, la desviación estándar es 8961.58 y el rango intercuartílico (IQR) es 17332. Después de la transformación, el CV se reduce significativamente a 2.29, la desviación estándar se reduce a 0.24 y el IQR se reduce a 0.47. Estas reducciones indican una disminución significativa en la variabilidad de la serie después de la transformación. 2.10 Justificación Prueba de Dickey-Fuller (ADF) estacionariedad : Es importante evaluar la estacionariedad de la serie temporal antes de aplicar modelos de series temporales. La prueba ADF nos permite determinar si la serie es estacionaria o no, lo que influye en la selección y aplicación de modelos adecuados. Diferenciación de la Serie Temporal: La diferenciación es un paso común para lograr la estacionariedad en series temporales no estacionarias. Eliminar tendencias y patrones no estacionarios permite aplicar modelos más simples y eficientes, adicionalmente mejorar la interpretabilidad de los resultados al eliminar tendencias y variaciones. la transformación: La transformación se utilizo para estabilizar la varianza y controlar la tendencia en la serie temporal. Esto es importante para mejorar la interpretacion de los datos y facilitar la identificación de patrones temporales. Además, la reducción de la variabilidad puede hacer que la serie sea más predecible y fácil de modela.. "]]
